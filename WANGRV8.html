<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WANGR V8 Launcher — 自動偵測版 (Hook Cocos)</title>
<style>
  body{font-family: "Microsoft JhengHei","Noto Sans TC",Arial; background:#0f0f12;color:#e8e8e8;margin:0}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  .panel{background:#151517;border-radius:10px;padding:14px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.03)}
  label{display:inline-block;width:120px}
  input[type=text]{padding:8px;border-radius:6px;border:1px solid #222;background:#0b0b0c;color:#eaeaea;width:520px}
  button{padding:8px 12px;border-radius:8px;background:#ffb200;border:0;color:#111;font-weight:700;cursor:pointer}
  pre{background:#0b0b0c;padding:10px;border-radius:8px;color:#bfbfbf;overflow:auto}
  .ok{color:#8fe08f;font-weight:700}
  .err{color:#ff9090;font-weight:700}
  .small{font-size:13px;color:#bdbdbd}
  .row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .flex{display:flex;gap:8px;align-items:center}
  .badge{background:#222;padding:6px 8px;border-radius:8px;color:#ddd}
  .green{background:#2ea44f;color:#fff;padding:6px 8px;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <h2>WANGR V8 Launcher — 自動偵測版（Hook Cocos / drawText）</h2>

  <div class="panel">
    <div class="row">
      <label>遊戲 URL</label>
      <input id="gameUrl" type="text" value="https://gameb.minitt.tw/web/index.html"/>
      <button id="openBtn">開啟遊戲並啟動偵測</button>
    </div>
    <div class="small">說明：此啟動器會打開遊戲頁（新分頁），嘗試在該分頁注入偵測程式（hook Cocos label / drawText）。若該頁與此檔非同源（跨域），注入會被瀏覽器擋下，系統會提示下一步。</div>
  </div>

  <div class="panel">
    <div style="margin-bottom:8px"><strong>Firebase 設定（若要寫入 Firestore，請填入你的 config；留空表示只在本頁顯示偵測結果）</strong></div>
    <div class="row">
      <label>apiKey</label><input id="fb_apiKey" type="text" placeholder="API Key" style="width:420px"/>
    </div>
    <div class="row">
      <label>authDomain</label><input id="fb_authDomain" type="text" placeholder="project.firebaseapp.com" style="width:420px"/>
    </div>
    <div class="row">
      <label>projectId</label><input id="fb_projectId" type="text" placeholder="projectId" style="width:420px"/>
    </div>
    <div class="row">
      <label>appId</label><input id="fb_appId" type="text" placeholder="1:...:web:..." style="width:420px"/>
    </div>
    <div class="small">若你不需要上傳至 Firebase，留空即可。</div>
  </div>

  <div class="panel">
    <div style="margin-bottom:8px"><strong>偵測設定</strong></div>
    <div class="row">
      <label>Boss 名單</label>
      <input id="bossList" type="text" value="巴拉卡斯,死靈君王．海露拜,長老會．巴陸德,吉爾達斯" style="width:520px"/>
    </div>
    <div class="row">
      <label>偵測頻率</label>
      <input id="pollSec" type="text" value="0.8" style="width:80px"/> 秒（Cocos hook 成功後不用頻繁）
      <div style="flex:1"></div>
      <button id="testParse">測試解析範例訊息</button>
    </div>
    <div class="small">說明：Hook 方式會監控 Cocos 中的文字渲染函式（不影響遊戲）。</div>
  </div>

  <div class="panel">
    <div style="margin-bottom:8px"><strong>狀態 / Log</strong></div>
    <div class="row">
      <div class="badge">Launcher 狀態： <span id="status" class="small">待命</span></div>
      <div class="badge">注入狀態： <span id="injectState" class="small">尚未</span></div>
      <div class="badge">Firebase： <span id="fbState" class="small">未初始化</span></div>
      <div style="flex:1"></div>
      <button id="openConsole" class="green">打開偵測結果視窗</button>
    </div>
    <pre id="log" style="height:240px">log...</pre>
  </div>

  <div class="panel">
    <div style="margin-bottom:8px"><strong>操作指引（快速）</strong></div>
    <ol>
      <li>儲存本檔並用 Chrome 開啟（File 或本機 HTTP server）。</li>
      <li>輸入遊戲 URL（預設已填），按「開啟遊戲並啟動偵測」。</li>
      <li>新分頁會打開遊戲；Launcher 會每 1 秒嘗試跟那個分頁建立「同源注入」。成功後會顯示「注入成功」。</li>
      <li>若注入失敗，請嘗試把 Launcher 與遊戲放在「同一個網域」或使用本機 proxy。或按下「打開偵測結果視窗」以取得更多 debug 資訊。</li>
    </ol>
  </div>
</div>

<script>
/*
  WANGR V8 Launcher - Injector + Hook for Cocos draw/Label
  - 開啟子視窗 (gameWin)，嘗試注入腳本（同源情況)
  - 若注入成功，會在 child window 裡覆寫 cc.Label.prototype.string setter 與 cc.Label.prototype._updateRenderData（兼容不同版本）
  - 當聊天文字或系統訊息中出現 boss 關鍵字時，會把該訊息傳回 opener（本頁）
  - 本頁可選擇將事件寫入 Firebase（若提供 config）
*/

/* ---------- Helper ---------- */
const $ = id=>document.getElementById(id);
function log(...a){ const p=$('log'); p.textContent = (new Date()).toLocaleTimeString() + '  ' + a.join(' ') + '\n' + p.textContent; }
function setStatus(s){ $('status').textContent = s; }
function setInject(s){ $('injectState').textContent = s; }
function setFB(s){ $('fbState').textContent = s; }

/* ---------- state ---------- */
let gameWin = null;
let checkInterval = null;
let hookInjected = false;
let firebaseInitialized = false;
let fb = null;
let firestore = null;

/* ---------- Firebase init if provided ---------- */
async function tryInitFirebase(){
  const apiKey = $('fb_apiKey').value.trim();
  const projectId = $('fb_projectId').value.trim();
  const authDomain = $('fb_authDomain').value.trim();
  const appId = $('fb_appId').value.trim();
  if(!apiKey || !projectId || !authDomain || !appId){
    setFB('未初始化（留空）');
    return;
  }
  try{
    if(window.firebase && firebase.apps && firebase.apps.length>0){ log('Firebase already loaded'); firebaseInitialized=true; setFB('已初始化'); firestore = firebase.firestore(); return; }
    // load compat SDKs
    await new Promise((res,rej)=>{
      const s=document.createElement('script'); s.src='https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s);
    });
    await new Promise((res,rej)=>{
      const s=document.createElement('script'); s.src='https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s);
    });
    const config = {
      apiKey, authDomain, projectId, appId
    };
    firebase.initializeApp(config);
    firestore = firebase.firestore();
    firebaseInitialized = true;
    setFB('已初始化');
    log('Firebase init OK');
  }catch(e){
    log('Firebase init 失敗', e);
    setFB('初始化失敗');
  }
}

/* ---------- open game & attempt inject ---------- */
$('openBtn').addEventListener('click', async ()=>{
  const url = $('gameUrl').value.trim();
  if(!url){ alert('請輸入遊戲 URL'); return; }
  setStatus('開啟遊戲頁面...');
  // open new window
  gameWin = window.open(url, '_blank');
  if(!gameWin){ alert('被瀏覽器阻擋彈窗，請允許彈窗或手動在新分頁開啟遊戲'); setStatus('彈窗被阻擋'); return; }
  setStatus('遊戲已開啟，等待同源注入（最多 40 秒）');
  await tryInitFirebase();

  // start poll to see when we can access gameWin (same-origin)
  let tries = 0; hookInjected=false;
  if(checkInterval) clearInterval(checkInterval);
  checkInterval = setInterval(async ()=>{
    tries++;
    if(tries>40){ clearInterval(checkInterval); setStatus('注入失敗（可能跨域）'); setInject('注入失敗'); log('超時：無法同源存取子視窗（可能跨域）'); return; }
    try{
      // try a simple access
      const doc = gameWin.document;
      // if accessible, inject
      if(!hookInjected){
        setStatus('可存取子視窗，開始注入...');
        const injected = injectHookIntoChild(gameWin);
        if(injected){
          hookInjected = true;
          setInject('注入成功');
          setStatus('偵測啟動（在遊戲分頁）');
          log('注入成功');
          clearInterval(checkInterval);
        } else {
          log('注入失敗（注入函式返回 false）');
        }
      }
    }catch(e){
      // still cross-origin
      setStatus('等待子視窗允許（同源）... ' + tries + ' / 40');
    }
  }, 1000);
});

/* ---------- inject function (stringify and append) ---------- */
/* returns true on successful inject attempt */
function injectHookIntoChild(childWin){
  try{
    // build the injector script as a string
    const bossCsv = $('bossList').value.split(',').map(s=>s.trim()).filter(Boolean);
    const pollSec = parseFloat($('pollSec').value) || 0.8;
    const injector = `
(function(){
  if(window.__WANGR_V8_INJECTED) return;
  window.__WANGR_V8_INJECTED = true;
  const BOSS_KEYS = ${JSON.stringify(bossCsv)};
  const POLL_SEC = ${pollSec};
  const sendToOpener = (type,payload)=>{ try{ if(window.opener && window.opener.postMessage){ window.opener.postMessage({ wangr_v8: true, type, payload }, '*'); } }catch(e){} };

  function tryHookCc(){
    if(!window.cc){ return false; }
    try{
      // Different cocos versions: try both cc.Label and cc.LabelTTF / cc.Label.prototype
      let hooked=false;
      const safe = (fn)=>{ try{ fn(); }catch(e){ console.warn('wangr safe', e); } };

      // prefer defining setter for 'string' property (Cocos often uses label.string = 'text')
      safe(()=>{
        const proto = window.cc && (window.cc.Label ? window.cc.Label.prototype : (window.cc.LabelTTF ? window.cc.LabelTTF.prototype : null));
        if(proto && Object.getOwnPropertyDescriptor(proto, 'string') && !proto.__wangr_hooked_string){
          const desc = Object.getOwnPropertyDescriptor(proto, 'string');
          const originalSet = desc.set || function(v){ this._string = v; };
          const originalGet = desc.get || function(){ return this._string; };
          Object.defineProperty(proto, 'string', {
            get: function(){ return originalGet.call(this); },
            set: function(val){
              try{
                // call original
                originalSet.call(this, val);
              }catch(e){}
              // run detection
              try{
                if(val && typeof val === 'string'){
                  BOSS_KEYS.forEach(k=>{
                    if(val.indexOf(k)!==-1){
                      // found boss mention
                      const payload = { boss:k, text:val, ts: Date.now(), nodeName: this.node ? (this.node.name || '') : '' };
                      sendToOpener('boss_detect', payload);
                    }
                  });
                }
              }catch(e){}
            },
            configurable: true
          });
          proto.__wangr_hooked_string = true;
          hooked=true;
        }
      });



      // also try hooking draw or _updateRenderData for other cocos versions
      safe(()=>{
        let prototypeCandidates = [];
        if(window.cc && window.cc.Label){ prototypeCandidates.push(window.cc.Label.prototype); }
        if(window.cc && window.cc.LabelTTF){ prototypeCandidates.push(window.cc.LabelTTF.prototype); }
        prototypeCandidates.forEach(proto=>{
          if(proto && proto._updateRenderData && !proto.__wangr_hooked_update){
            const orig = proto._updateRenderData;
            proto._updateRenderData = function(){
              try{ orig.apply(this, arguments); }catch(e){}
              try{
                const txt = (this.string || this._string || '');
                if(txt && typeof txt === 'string'){
                  BOSS_KEYS.forEach(k=>{
                    if(txt.indexOf(k)!==-1){
                      const payload = { boss:k, text:txt, ts: Date.now(), nodeName: this.node ? (this.node.name || '') : '' };
                      sendToOpener('boss_detect', payload);
                    }
                  });
                }
              }catch(e){}
            };
            proto.__wangr_hooked_update = true;
            hooked=true;
          }
        });
      });

      // fallback: observe cc.director runScene and intercept nodes named chat or text labels
      safe(()=>{
        if(window.cc && window.cc.scene && !window.__wangr_xpath_observer){
          // try scanning scene graph periodically
          window.__wangr_xpath_observer = setInterval(()=>{
            try{
              const allLabels = [];
              // traverse nodes (limited)
              function walk(node){
                if(!node || !node.children) return;
                node.children.forEach(ch=>{
                  if(ch._components) allLabels.push(...ch._components.filter(c=>c && (c.string || c._string)));
                  walk(ch);
                });
              }
              const root=window.cc && window.cc.director && window.cc.director.getScene && window.cc.director.getScene();
              if(root) walk(root);
              allLabels.forEach(lbl=>{
                const txt = lbl.string || lbl._string || '';
                if(txt && typeof txt === 'string'){
                  BOSS_KEYS.forEach(k=>{
                    if(txt.indexOf(k)!==-1){
                      const payload = { boss:k, text:txt, ts: Date.now(), nodeName: (lbl.node && lbl.node.name) || '' };
                      sendToOpener('boss_detect', payload);
                    }
                  });
                }
              });
            }catch(e){}
          }, Math.max(500, POLL_SEC*1000));
        }
      });

      return hooked;
    }catch(e){
      return false;
    }
  }

  // repeatedly try to hook until success
  (function tryLoop(){
    const ok = tryHookCc();
    if(ok){
      sendToOpener('hook_ok', { msg:'hooked' });
    } else {
      setTimeout(tryLoop, 800);
    }
  })();
})();
    `;
    // append injector script to child document (if same origin)
    const script = childWin.document.createElement('script');
    script.type = 'text/javascript';
    script.textContent = injector;
    childWin.document.documentElement.appendChild(script);
    // also setup message listener in opener (this page) is already present; child will postMessage
    return true;
  }catch(e){
    log('注入例外：', e);
    return false;
  }
}

/* ---------- handle messages from child (injected hook) ---------- */
window.addEventListener('message', async (ev)=>{
  try{
    const data = ev.data;
    if(!data || !data.wangr_v8) return;
    if(data.type === 'boss_detect'){
      const payload = data.payload;
      log('[偵測] ' + payload.boss + ' => ' + payload.text);
      // show a notification (optional)
      try{
        if(Notification && Notification.permission === 'granted'){
          new Notification('王偵測：' + payload.boss, { body: payload.text });
        }
      }catch(e){}
      // if firebase inited, write a record
      if(firebaseInitialized && firestore){
        try{
          await firestore.collection('auto_events').add({ ts: payload.ts, boss: payload.boss, text: payload.text });
          log('已寫入 Firestore auto_events');
        }catch(e){
          log('寫入 Firestore 失敗', e.message || e);
        }
      }
    } else if(data.type === 'hook_ok'){
      log('子視窗：Hook 已就緒');
    }
  }catch(e){}
});

/* ---------- test parse sample ---------- */
$('testParse').addEventListener('click', ()=>{
  const sample = '【系統】區域領主 巴拉卡斯 重生在地圖 地獄';
  const bosses = $('bossList').value.split(',').map(s=>s.trim()).filter(Boolean);
  const found = bosses.filter(b=> sample.indexOf(b)!==-1);
  alert('在範例訊息中抓到：' + (found.length? found.join(',') : '無') + '\n範例文本：' + sample);
});

/* ---------- open debug window ---------- */
$('openConsole').addEventListener('click', ()=>{
  const w = window.open('', '_blank', 'width=700,height=600');
  w.document.body.style.background='#0b0b0c';
  w.document.title='WANGR V8 - Debug';
  const pre = w.document.createElement('pre');
  pre.style.color='#ddd'; pre.style.padding='10px';
  w.document.body.appendChild(pre);
  // copy logs periodically
  const iv = setInterval(()=>{ pre.textContent = $('log').textContent; }, 500);
  w.addEventListener('beforeunload', ()=> clearInterval(iv));
});

/* ---------- try auto ask notification permission (user gesture recommended) ---------- */
if(Notification && Notification.permission !== 'granted'){
  // don't auto prompt, but show status
  log('若要桌面通知，請點右上角網站圖示允許通知（或手動允許）');
}

/* ---------- init firebase button binding (attempt init early) ---------- */
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState === 'visible') tryInitFirebase();
});
</script>
</body>
</html>
