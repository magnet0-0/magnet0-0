<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>WANGR12 PRO v7 — HTML 主體</title>
<style>

:root{
  --bg:#0f0f10; --card:#1a1a1c; --muted:#bdbdbd;
  --accent:#ffb200; --danger:#e53935; --green:#28a745;
  --text:#e8e8e8;
  --glass: rgba(255,255,255,0.03);
}
*{box-sizing:border-box}
html,body{height:100%;}
body{
  margin:0;
  background: linear-gradient(180deg, #0b0b0d 0%, #0f0f12 100%);
  color:var(--text);
  font-family: "Microsoft JhengHei","Noto Sans TC",Helvetica,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}

/* topbar */
.topbar{
  background:rgba(11,11,12,0.95);
  padding:12px 18px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  position:sticky;
  top:0;
  z-index:60;
  border-bottom:1px solid var(--glass);
}
.next-left{display:flex;flex-direction:column;align-items:flex-start;gap:4px;}
.next-label{color:#ffffff;font-size:16px;}
.next-name{font-size:32px;font-weight:900;color:#ffffff;line-height:1;}
.next-count{color:var(--danger);font-weight:900;font-size:48px;margin-top:6px;}
.top-right{display:flex;align-items:center;gap:12px;}

/* container & panels */
.container{max-width:1200px;margin:18px auto;padding:0 16px;}
.panel{background:var(--card);border-radius:12px;padding:14px;margin-bottom:16px;box-shadow:0 8px 30px rgba(0,0,0,0.6);}

/* inputs & buttons */
.row{display:flex;gap:12px;align-items:center;margin-bottom:8px;flex-wrap:wrap;}
.input, input[type="number"], select{background:#0b0b0c;border:1px solid #222;padding:8px 10px;border-radius:8px;color:var(--text);outline:none;}
.input.small{width:80px;}
.btn{background:#2f2f2f;color:#fff;border-radius:8px;padding:8px 12px;border:0;cursor:pointer;transition:all .12s ease;}
.btn.orange{background:var(--accent);color:#111;font-weight:800;}
.btn.green{background:var(--green);color:#fff;font-weight:800;border-radius:10px;padding:8px 14px;}
.btn.red{background:var(--danger);color:#fff;font-weight:800;border-radius:10px;padding:8px 14px;}
.btn:hover{filter:brightness(.9);transform:translateY(-1px);}

/* grid & cards */
.grid{display:grid;grid-template-columns:repeat(2,1fr);gap:18px;margin-top:14px;}
@media(max-width:900px){.grid{grid-template-columns:1fr}}
.boss-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;min-height:160px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.02);}
.boss-title{color:#32b7ff;font-weight:800;font-size:18px;margin-bottom:6px;}
.info{color:#d6d6d6;margin:6px 0;font-size:14px;}
.next-time{color:var(--danger);font-weight:900;font-size:18px;}
.countdown{font-weight:900;color:#fff;font-size:16px;}

/* inline controls */
.controls-inline{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;}
.smallbtn{background:#2b2b2b;border-radius:8px;padding:8px 10px;color:#fff;border:0;cursor:pointer;}
.smallbtn:hover{filter:brightness(.95);}

/* manual inputs */
.manual-row{display:flex;gap:8px;align-items:center;margin-top:8px;}
.manual-row .input.small{width:64px;padding:6px 8px;text-align:center;}
.manual-row .btn{padding:6px 10px}

/* future/last */
.future{color:#c9c9c9;margin-top:12px;font-size:13px;}
.lastmod{color:#bdbdbd;margin-top:8px;font-size:13px;}
.footer-note{color:var(--muted);margin-top:8px;}

/* subtle helpers */
.pale{background:#222;padding:6px 8px;border-radius:8px;color:#ddd;}
.ktt{display:inline-block;width:40px;text-align:center;}

/* focus styles */
.input:focus, .smallbtn:focus, .btn:focus{box-shadow:0 4px 12px rgba(0,0,0,0.6);outline:none;border-color:rgba(255,255,255,0.06);}

</style>
</head>
<body>
  <!-- 頂部 Next 區塊（左側顯示下一個王和倒數；右側顯示音量與通知） -->
  <header id="topbar" style="position:sticky;top:0;background:#0b0b0c;padding:10px;display:flex;justify-content:space-between;align-items:center;">
    <div id="next-left" style="display:flex;flex-direction:column;align-items:flex-start;">
      <div style="font-size:18px;color:#fff;">下一個：</div>
      <div id="topName" style="font-size:32px;font-weight:900;color:#fff;margin-top:4px;">載入中...</div>
      <div id="topCd" style="font-size:48px;color:#e53935;font-weight:900;margin-top:6px;">--:--:--</div>
    </div>
    <div id="top-right" style="display:flex;align-items:center;gap:12px;">
      <label style="color:#ccc;font-size:13px;margin-right:6px;">音量</label>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8"/>
      <button id="allowNotif">允許通知＋啟用音效</button>
      <button id="muteAll">關閉通知/音效</button>
    </div>
  </header>

  <!-- 新增王的控制面板 -->
  <main style="max-width:1200px;margin:18px auto;padding:0 16px;">
    <section id="panel-add" style="background:#1a1a1c;padding:14px;border-radius:12px;margin-bottom:16px;">
      <div style="color:#fff;margin-bottom:8px;">資料來源： Firestore 集合 /bosses（Document ID 使用王名）</div>
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;">
        <label>名稱：</label>
        <input id="newName" placeholder="例如：火龍"/>
        <label>重生(分)：</label>
        <input id="newRespawn" type="number" value="120" style="width:80px;"/>
        <label>擊殺耗時(分)：</label>
        <input id="newKill" type="number" value="1" style="width:80px;"/>
        <button id="addBtn">新增王</button>
      </div>
      <div style="color:#9a9a9a;margin-top:8px;">新增會寫入 Firestore；顯示順序依 Firestore 回傳（不排序）。</div>
    </section>

    <!-- 王卡區（雙欄） -->
    <section id="grid" aria-live="polite" style="display:grid;grid-template-columns:repeat(2,1fr);gap:18px;">
      <!-- 各王卡會由 JS 動態生成插入於此 -->
    </section>

    <!-- 歷史紀錄 -->
    <section id="panel-history" style="background:#1a1a1c;padding:14px;border-radius:12px;margin-top:16px;">
      <div style="color:#9a9a9a;">歷史紀錄（簡要）：</div>
      <div id="history">尚無歷史紀錄</div>
    </section>
  </main>

  <!-- Placeholder: 之後將由 JS / CSS 注入功能、樣式與事件 -->
  <!-- 請確保在同一目錄放入最終 CSS / JS，或把它們內嵌到此檔案中。 -->


<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
/* WANGR12 PRO v7 - JS (optimized) */
/* Place this script after the HTML and CSS (or include as external file). */
/* Requires Firebase compat scripts to be loaded (firebase-app-compat.js and firebase-firestore-compat.js) */

// === CONFIG: Hard-coded Firebase config (A = YES) ===
const firebaseConfig = {
  apiKey: "AIzaSyDs9i1UKuvUohyE2dYQYk6nSBXHrvTvzEM",
  authDomain: "wangr-sync2.firebaseapp.com",
  projectId: "wangr-sync2",
  storageBucket: "wangr-sync2.firebasestorage.app",
  messagingSenderId: "1010873667172",
  appId: "1:1010873667172:web:ba68012141814fed241971"
};
// Initialize compat
if(!firebase.apps.length) firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// State & caches
const bosses = {}; // id -> normalized data
const cardEls = {}; // id -> DOM refs & data
let unsub = null;
let notified3 = {};
let notifiedDone = {};
let masterVol = 0.8;

// Audio setup
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
function beep(freq=880, dur=120, vol=0.9){
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq;
    g.gain.value = vol * masterVol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, dur);
  }catch(e){ console.warn('beep error', e); }
}
function playPattern(n, gap=220, tone=140){
  let i=0; const run = ()=>{ if(i>=n) return; beep(880,tone,0.9); if(navigator.vibrate) navigator.vibrate(90); i++; setTimeout(run,gap); }; run();
}

// Helpers
const $ = id => document.getElementById(id);
function pad(n){ return String(n).padStart(2,'0'); }
function fmtTime(ms){ if(!ms) return '--:--:--'; const d = new Date(ms); return d.toLocaleTimeString('zh-TW', {hour12:false}); }
function msToHMS(ms){ if(ms===Infinity) return '--:--:--'; if(ms<=0) return '00:00:00'; const s=Math.floor(ms/1000); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); const sec = s%60; return pad(h)+':'+pad(m)+':'+pad(sec); }
function nowMs(){ return Date.now(); }

// Compute next spawn
function computeNext(doc){ if(!doc.lastkill || doc.lastkill===0) return null; return doc.lastkill + (doc.respawn||0)*60000; }
function remainingMs(doc){ const nxt = computeNext(doc); if(!nxt) return Infinity; return nxt - Date.now(); }

// Create or update card (preserve manual inputs)
function createOrUpdateCard(id, data){
  if(cardEls[id]){
    // update data and static displays
    cardEls[id].data = data;
    cardEls[id].lastEl.textContent = '上次擊殺： ' + (data.lastkill? fmtTime(data.lastkill): '--:--:--');
    cardEls[id].ktEl.textContent = data.killtime || 0;
    cardEls[id].lastmod.textContent = '最後修改(LastKill)： ' + (data.lastkill? fmtTime(data.lastkill): '--:--:--');
    // update future preview
    updateFutureDisplay(id);
    return;
  }
  // Build card DOM
  const card = document.createElement('div'); card.className = 'boss-card';
  const title = document.createElement('div'); title.className = 'boss-title'; title.textContent = id;
  const last = document.createElement('div'); last.className = 'info'; last.textContent = '上次擊殺： ' + (data.lastkill? fmtTime(data.lastkill): '--:--:--');
  const nextEl = document.createElement('div'); nextEl.innerHTML = '下一次重生： <span class="next-time">' + (computeNext(data)? fmtTime(computeNext(data)) : '--:--:--') + '</span>';
  const countdownEl = document.createElement('div'); countdownEl.className = 'info'; countdownEl.innerHTML = '倒數： <span class="countdown">' + (computeNext(data)? msToHMS(remainingMs(data)) : '--:--:--') + '</span>';
  // Controls (kill, +/- minutes, delete)
  const controls = document.createElement('div'); controls.className = 'controls-inline';
  const killBtn = document.createElement('button'); killBtn.className = 'btn green'; killBtn.textContent = '已擊殺 (完成)'; killBtn.addEventListener('click', ()=> markKilled(id));
  controls.appendChild(killBtn);
  ['+1','-1','+5','-5'].forEach(txt=>{ const b=document.createElement('button'); b.className='smallbtn'; b.textContent = txt; b.addEventListener('click', ()=> adjustMinutes(id, parseInt(txt))); controls.appendChild(b); });
  const del = document.createElement('button'); del.className='btn red'; del.textContent = '刪除'; del.addEventListener('click', ()=> deleteBoss(id)); controls.appendChild(del);
  // killtime controls
  const kt = document.createElement('div'); kt.className = 'info'; kt.innerHTML = '擊殺耗時： <strong id="kt-'+id+'">' + (data.killtime||0) + '</strong> 分 ';
  const kmin = document.createElement('button'); kmin.className='smallbtn'; kmin.textContent='-1'; kmin.addEventListener('click', ()=> adjustKilltime(id,-1));
  const kplus = document.createElement('button'); kplus.className='smallbtn'; kplus.textContent='+1'; kplus.addEventListener('click', ()=> adjustKilltime(id,1));
  kt.appendChild(kmin); kt.appendChild(kplus);
  // manual inputs (preserved)
  const manual = document.createElement('div'); manual.className='manual-row';
  const nowBtn = document.createElement('button'); nowBtn.className='smallbtn'; nowBtn.textContent = '現在(完成)';
  const hh = document.createElement('input'); hh.className='input small'; hh.placeholder='時'; hh.type='number'; hh.min=0; hh.max=23;
  const mm = document.createElement('input'); mm.className='input small'; mm.placeholder='分'; mm.type='number'; mm.min=0; mm.max=59;
  const ss = document.createElement('input'); ss.className='input small'; ss.placeholder='秒'; ss.type='number'; ss.min=0; ss.max=59;
  const apply = document.createElement('button'); apply.className='btn'; apply.textContent='套用';
  nowBtn.addEventListener('click', ()=>{ const d = new Date(); hh.value = d.getHours(); mm.value = d.getMinutes(); ss.value = d.getSeconds(); });
  apply.addEventListener('click', ()=> applyManual(id, hh.value, mm.value, ss.value));
  manual.appendChild(nowBtn); manual.appendChild(hh); manual.appendChild(mm); manual.appendChild(ss); manual.appendChild(apply);
  // future and lastmod
  const future = document.createElement('div'); future.className = 'future';
  const lastmod = document.createElement('div'); lastmod.className = 'lastmod'; lastmod.textContent = '最後修改(LastKill)： ' + (data.lastkill? fmtTime(data.lastkill): '--:--:--');
  // assemble
  card.appendChild(title); card.appendChild(last); card.appendChild(nextEl); card.appendChild(countdownEl);
  card.appendChild(controls); card.appendChild(kt); card.appendChild(manual); card.appendChild(future); card.appendChild(lastmod);
  $('grid').appendChild(card);
  // cache refs
  cardEls[id] = {
    card, nextEl: nextEl.querySelector('span'), countdownEl: countdownEl.querySelector('span'),
    ktEl: kt.querySelector('strong'), hh, mm, ss, manual, lastEl: last, lastmod, data
  };
  updateFutureDisplay(id);
}

// Update future times preview
function updateFutureDisplay(id){
  const e = cardEls[id]; if(!e) return;
  const data = e.data; const nextTs = computeNext(data);
  const future = e.card.querySelector('.future');
  if(nextTs){ const arr=[]; for(let i=0;i<4;i++) arr.push(fmtTime(nextTs + i*(data.respawn||0)*60000)); future.textContent = '未來： ' + arr.join(' ・ '); } else future.textContent = '未來： --';
}

// Minimal tick update (only updates dynamic texts)
function tickUpdate(){
  const ids = Object.keys(cardEls); let topName = null; let topRem = Infinity;
  ids.forEach(id=>{
    const e = cardEls[id]; const data = e.data;
    const nextTs = computeNext(data);
    const rem = remainingMs(data);
    e.countdownEl.textContent = nextTs ? msToHMS(rem) : '--:--:--';
    e.nextEl.textContent = nextTs ? fmtTime(nextTs) : '--:--:--';
    if(rem < topRem){ topRem = rem; topName = id; }
  });
  $('topName').textContent = topName || '—';
  $('topCd').textContent = topRem===Infinity ? '--:--:--' : msToHMS(topRem);
}

// Firestore write helper
async function writeMerge(id, data){ return db.collection('bosses').doc(id).set(data, { merge:true }); }

// Actions
async function markKilled(id){
  const finish = Date.now();
  try{ await writeMerge(id, { lastkill: finish }); }catch(e){ alert('寫入失敗：' + e.message); }
}
async function applyManual(id, hh, mm, ss){
  const H=parseInt(hh,10), M=parseInt(mm,10), S=parseInt(ss,10);
  if(isNaN(H)||isNaN(M)||isNaN(S)){ alert('請輸入時/分/秒或按現在(完成)'); return; }
  const now = new Date(); const dt = new Date(now.getFullYear(), now.getMonth(), now.getDate(), H, M, S, 0);
  try{ await writeMerge(id, { lastkill: dt.getTime() }); }catch(e){ alert('寫入失敗：' + e.message); }
}
async function adjustMinutes(id, delta){
  const doc = bosses[id]; const base = doc.lastkill && doc.lastkill>0 ? doc.lastkill : Date.now();
  const newLast = base + delta*60000; try{ await writeMerge(id, { lastkill: newLast }); }catch(e){ alert('寫入失敗：' + e.message); }
}
async function adjustKilltime(id, delta){
  const doc = bosses[id]; const newKt = Math.max(0,(doc.killtime||0)+delta); try{ await writeMerge(id,{ killtime: newKt }); }catch(e){ alert('寫入失敗：' + e.message); }
}
async function deleteBoss(id){ if(!confirm('確認刪除 '+id+' 嗎？')) return; try{ await db.collection('bosses').doc(id).delete(); }catch(e){ alert('刪除失敗：' + e.message); } }

// Add new boss
$('addBtn').addEventListener('click', async ()=>{
  const n = $('newName').value.trim(); const r = parseInt($('newRespawn').value,10)||120; const k = parseInt($('newKill').value,10)||1;
  if(!n){ alert('請輸入名稱'); return; }
  try{ await db.collection('bosses').doc(n).set({ name:n, respawn:r, killtime:k, lastkill:0 }); $('newName').value=''; alert('新增完成'); }catch(e){ alert('新增失敗：' + e.message); }
});

// Realtime listener: create or update cards but preserve manual inputs
function startListener(){
  if(unsub) unsub();
  unsub = db.collection('bosses').onSnapshot(snap=>{
    const seen = new Set();
    snap.docs.forEach(d=>{
      const data = d.data(); const id = d.id;
      const normalized = { name: data.name || id, respawn: Number(data.respawn||0), killtime: Number(data.killtime||0), lastkill: Number(data.lastkill||0) };
      bosses[id] = normalized; seen.add(id);
      createOrUpdateCard(id, normalized);
    });
    // remove deleted
    Object.keys(cardEls).forEach(id=>{ if(!seen.has(id)){ cardEls[id].card.remove(); delete cardEls[id]; delete bosses[id]; } });
    // update futures
    Object.keys(cardEls).forEach(id=> updateFutureDisplay(id));
    tickUpdate();
  }, err=>{ console.error('snapshot err', err); alert('Firestore 讀取錯誤：' + err.message); });
}

// Scheduler: reminders + auto-advance
setInterval(()=>{
  Object.keys(bosses).forEach(id=>{
    const data = bosses[id]; const rem = remainingMs(data);
    if(rem<=180000 && rem>0 && !notified3[id]){ playPattern(3,240,140); notified3[id]=true; try{ if(Notification.permission==='granted') new Notification('三分鐘提醒', { body: id + ' 即將重生' }); }catch(e){} }
    if(rem<=0 && !notifiedDone[id]){ playPattern(5,160,100); notifiedDone[id]=true; const nextTs = computeNext(data); if(nextTs){ writeMerge(id, { lastkill: nextTs }).catch(e=>console.error('autoAdvance error', e)); } }
    if(rem>180000) notified3[id]=false;
    if(rem>0) notifiedDone[id]=false;
  });
  tickUpdate();
}, 1000);

// Controls
$('vol').addEventListener('input', e=>{ masterVol = parseFloat(e.target.value); });
$('allowNotif').addEventListener('click', async ()=>{ if(window.Notification && Notification.permission!=='granted') await Notification.requestPermission(); try{ await audioCtx.resume(); alert('通知/聲效已啟用'); }catch(e){ alert('無法啟用聲效'); } });
$('muteAll').addEventListener('click', ()=>{ masterVol=0; $('vol').value=0; alert('聲效已關閉'); });

// Start
startListener();

/* End of JS file */

</script>
</body>
</html>
