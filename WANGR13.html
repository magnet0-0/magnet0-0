<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‹åˆ·æ–°ç›£æ§ç³»çµ± Firestore ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
        }
        .header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 20px 40px; background: rgba(22,33,62,0.95);
            backdrop-filter: blur(10px); box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: relative;
            z-index: 10;
        }
        #countdown {
            font-size: 2.2em; font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,107,107,0.5);
            white-space: nowrap;
        }
        .search-container {
            position: relative; flex: 1; max-width: 400px; margin: 0 20px;
        }
        #search {
            width: 100%; padding: 12px 20px 12px 45px; background: rgba(15,52,96,0.8);
            border: 2px solid #533483; border-radius: 25px; color: #fff;
            font-size: 16px; transition: all 0.3s;
        }
        #search:focus { outline: none; border-color: #4ecdc4; box-shadow: 0 0 15px rgba(78,205,196,0.4); }
        .search-icon { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); color: #ccc; }
        .search-status {
            position: absolute; right: 15px; top: 50%; transform: translateY(-50%);
            font-size: 12px; color: #4ecdc4; background: rgba(78,205,196,0.2);
            padding: 2px 8px; border-radius: 10px;
        }
        .suggestions {
            position: absolute; top: 110%; left: 0; right: 0;
            background: #16213e; border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            max-height: 260px; overflow-y: auto; z-index: 20;
        }
        .suggestion-item {
            padding: 10px 16px; cursor: pointer; font-size: 14px;
        }
        .suggestion-item:hover {
            background: rgba(78,205,196,0.2);
        }
        #volumeControl { display: flex; align-items: center; gap: 10px; }
        #volume { width: 120px; height: 8px; background: #0f3460; border-radius: 5px; }
        .volume-label { font-size: 14px; }

        /* ç‹å¡æ•´é«”ï¼šæ©«å‘é•·æ¢ï¼Œä¸€åˆ—ä¸€å¼µ */
        .boss-cards {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px 40px 40px;
            max-width: 1200px;
            margin: 0 auto;
            min-height: 400px;
        }
        .no-results {
            grid-column: 1/-1; text-align: center; padding: 60px 20px;
            color: #ccc; font-size: 18px;
            background: rgba(15,52,96,0.5); border-radius: 20px; margin: 20px;
        }
        .boss-card {
            display: flex;
            align-items: flex-start;
            background: rgba(15,52,96,0.9);
            border-radius: 14px;
            padding: 16px 20px;
            width: 100%;
            min-height: 120px;
            position: relative;
            border: 1px solid rgba(83,52,131,0.3);
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        .boss-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0,0,0,0.35);
        }

        /* å·¦é‚Šä¸»å…§å®¹å€ï¼ˆåç¨± + è¼¸å…¥ + é æ¸¬æ™‚é–“ï¼‰ */
        .boss-main {
            flex: 1;
            display: grid;
            grid-template-columns: 180px 1fr 1fr;
            column-gap: 16px;
            row-gap: 8px;
        }
        .boss-name {
            grid-column: 1 / -1;
            font-size: 1.4em;
            margin-bottom: 4px;
            color: #4ecdc4;
            text-shadow: 0 0 10px rgba(78,205,196,0.5);
        }
        .input-group { margin: 4px 0; }
        .input-group label { display: block; margin-bottom: 4px; color: #ccc; font-size: 13px; }
        .input-group input {
            width: 100%; padding: 8px 10px; background: rgba(26,26,46,0.8);
            border: 1px solid #533483; border-radius: 8px; color: #fff; font-size: 14px;
            transition: border-color 0.3s;
        }
        .input-group input:focus { outline: none; border-color: #4ecdc4; }

        .predict-times {
            grid-column: 1 / -1;
            background: rgba(22,33,62,0.9); padding: 10px 12px; border-radius: 10px; margin: 6px 0 0;
            border-left: 4px solid #4ecdc4;
            font-size: 13px;
        }
        .predict-times strong { color: #4ecdc4; }
        .predict-item { margin: 2px 0; font-size: 12px; }

        /* å³é‚Šï¼šæé†’ + æŒ‰éˆ• */
        .boss-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            margin-left: 16px;
            min-width: 130px;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 4px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        .btn {
            padding: 8px 12px; border: none; border-radius: 10px; cursor: pointer;
            font-weight: bold; transition: all 0.3s; font-size: 13px;
        }
        .btn-primary { background: linear-gradient(45deg, #533483, #7b5cc5); color: #fff; }
        .btn-primary:hover { transform: scale(1.03); box-shadow: 0 5px 15px rgba(83,52,131,0.4); }
        .btn-danger { background: linear-gradient(45deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-danger:hover { transform: scale(1.03); box-shadow: 0 5px 15px rgba(255,107,107,0.4); }

        .toggle-container { display: flex; align-items: center; gap: 8px; }
        .toggle-label { font-size: 13px; color: #ccc; }
        .toggle {
            width: 46px; height: 22px; background: #333; border-radius: 25px;
            position: relative; cursor: pointer; transition: all 0.3s;
        }
        .toggle.active { background: #4ecdc4; }
        .toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 18px; height: 18px; background: #fff; border-radius: 50%;
            transition: 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .toggle.active::after { transform: translateX(22px); }

        .add-boss-btn {
            position: fixed; bottom: 30px; right: 30px;
            width: 60px; height: 60px; border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none; font-size: 24px; cursor: pointer;
            box-shadow: 0 10px 30px rgba(78,205,196,0.4); transition: all 0.3s;
            color: white; z-index: 100;
        }
        .add-boss-btn:hover { transform: scale(1.1); }

        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; background: rgba(0,0,0,0.8);
        }
        .modal-content {
            background: #16213e; margin: 10% auto; padding: 30px;
            border-radius: 20px; width: 90%; max-width: 500px;
            position: relative; animation: slideIn 0.3s;
        }
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to   { transform: translateY(0);      opacity: 1; }
        }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #fff; }

        @media (max-width: 900px) {
            .header { flex-direction: column; gap: 10px; align-items: flex-start; }
            #countdown { font-size: 1.8em; }
            .boss-main {
                grid-template-columns: 1fr 1fr;
            }
        }
        @media (max-width: 640px) {
            .boss-card { flex-direction: column; }
            .boss-right {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                margin-left: 0;
                margin-top: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div id="countdown">æ‰€æœ‰ç‹å·²é‡ç”Ÿ</div>
        <div class="search-container">
            <span class="search-icon">ğŸ”</span>
            <input type="text" id="search" placeholder="æœç´¢ç‹åç¨±...">
            <span class="search-status" id="searchStatus">å…± 0 å€‹ç‹</span>
            <div id="suggestions" class="suggestions" style="display:none;"></div>
        </div>
        <div id="volumeControl">
            <span class="volume-label">ğŸ”Š</span>
            <input type="range" id="volume" min="0" max="1" step="0.1" value="0.5">
            <span class="volume-label" id="volumeValue">50%</span>
        </div>
    </div>

    <div class="boss-cards" id="bossCards"></div>

    <button class="add-boss-btn" onclick="openAddModal()" title="æ–°å¢ç‹">+</button>

    <div id="addModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAddModal()">&times;</span>
            <h2>æ–°å¢ç‹ (å¯«å…¥ Firestore)</h2>
            <div class="input-group">
                <label>ç‹åç¨±</label>
                <input type="text" id="newBossName" placeholder="è¼¸å…¥ç‹åç¨±">
            </div>
            <div class="input-group">
                <label>é è¨­é‡ç”Ÿé–“éš”(åˆ†é˜)</label>
                <input type="number" id="newRespawnMinutes" value="60" min="1">
            </div>
            <div class="input-group">
                <label>æ“Šæ®ºç”¨æ™‚(åˆ†é˜)</label>
                <input type="number" id="newKillTime" value="0" min="0">
            </div>
            <button class="btn btn-primary" onclick="addNewBoss()" style="width:100%;margin-top:20px;">æ–°å¢ç‹</button>
        </div>
    </div>

    <audio id="alertSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAo" type="audio/wav">
    </audio>

    <script>
        // è‡ªå‹•ç‚ºæ¯å°ç€è¦½å™¨ç”¢ç”Ÿä¸€å€‹å›ºå®š IDï¼ˆå­˜åœ¨ localStorageï¼‰
        function getOrCreateOwnerId() {
            const KEY = 'WANGR_OWNER_ID';
            let id = localStorage.getItem(KEY);
            if (id) return id;
            const rand = Math.random().toString(36).slice(2);
            const ts = Date.now().toString(36);
            id = 'pc_' + ts + '_' + rand;
            localStorage.setItem(KEY, id);
            return id;
        }

        const OWNER_ID = getOrCreateOwnerId();

        const firebaseConfig = {
          apiKey: "AIzaSyAgV1fpP2XRS5fhgg4h0clp9AEJqAJtypo",
          authDomain: "wangr-sync.firebaseapp.com",
          projectId: "wangr-sync",
          storageBucket: "wangr-sync.firebasestorage.app",
          messagingSenderId: "178110502200",
          appId: "1:178110502200:web:adb5dc30cf34c5f0dc9dcd",
          measurementId: "G-ZN1H4KHEJR"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const bossesRef = db.collection('bosses');
        const bossNamesRef = db.collection('boss_events');      // æœå°‹ä¾†æº
        const templatesRef = db.collection('boss_templates');   // å…±ç”¨ç‹æ¨¡æ¿

        let bosses = {};
        const alertAudio = document.getElementById('alertSound');

        function init() {
            loadBosses();
            setupSearch();
            setupVolume();
            setInterval(updateGlobalCountdown, 1000);
        }

        // åªè¼‰å…¥æœ¬æ©Ÿ OWNER_ID çš„ç‹
        function loadBosses() {
            bossesRef.where('ownerId','==',OWNER_ID)
                .onSnapshot((snap) => {
                    const data = {};
                    snap.forEach(doc => {
                        data[doc.id] = doc.data();
                    });
                    bosses = data;
                    renderBossCards();
                    updateSearchStatus();
                    updateGlobalCountdown();
                }, (err) => {
                    console.error('è¼‰å…¥ bosses ç™¼ç”ŸéŒ¯èª¤ï¼š', err);
                    document.getElementById('searchStatus').textContent = 'è®€å–éŒ¯èª¤';
                });
        }

        // æœå°‹ï¼šå¾ boss_events æŠ“æ‰€æœ‰ç‹åï¼Œå‰ç«¯ includes
        function setupSearch() {
            const searchInput = document.getElementById('search');
            const suggBox = document.getElementById('suggestions');

            let allBossNames = [];

            bossNamesRef.onSnapshot((snap) => {
                const seen = new Set();
                const list = [];
                snap.forEach(doc => {
                    const data = doc.data();
                    const name = data.boss;
                    if (!name) return;
                    if (!seen.has(name)) {
                        seen.add(name);
                        list.push(name);
                    }
                });
                allBossNames = list;
            }, (err) => {
                console.error('åŒæ­¥ boss_events éŒ¯èª¤', err);
            });

            searchInput.addEventListener('input', (e) => {
                const keyword = e.target.value.trim();
                if (!keyword) {
                    suggBox.style.display = 'none';
                    suggBox.innerHTML = '';
                    return;
                }

                const lower = keyword.toLowerCase();
                const results = allBossNames.filter(n =>
                    n.toLowerCase().includes(lower)
                ).slice(0, 50);

                if (results.length === 0) {
                    suggBox.innerHTML = `<div class="suggestion-item">æ²’æœ‰æ‰¾åˆ°ã€Œ${keyword}ã€çš„ç‹å</div>`;
                } else {
                    suggBox.innerHTML = results.map(n =>
                        `<div class="suggestion-item" onclick="chooseBossName('${n.replace(/'/g,"&#39;")}')">${n}</div>`
                    ).join('');
                }
                suggBox.style.display = 'block';
            });

            document.addEventListener('click', (e) => {
                if (!document.querySelector('.search-container').contains(e.target)) {
                    suggBox.style.display = 'none';
                }
            });
        }

        function chooseBossName(name) {
            const suggBox = document.getElementById('suggestions');
            suggBox.style.display = 'none';
            document.getElementById('search').value = name;

            openAddModal();
            document.getElementById('newBossName').value = name;
        }

        function renderBossCards() {
            const container = document.getElementById('bossCards');
            container.innerHTML = '';

            const entries = Object.entries(bosses);
            if (entries.length === 0) {
                const noResult = document.createElement('div');
                noResult.className = 'no-results';
                noResult.innerHTML = `ç›®å‰å°šæœªæ–°å¢ä»»ä½•ç‹ï¼Œè«‹å¾å³ä¸‹è§’ã€Œ+ã€æˆ–ä¸Šæ–¹æœå°‹ç‹åå¾Œæ–°å¢ã€‚`;
                container.appendChild(noResult);
                return;
            }

            entries.forEach(([id, boss]) => {
                container.appendChild(createBossCard(id, boss));
            });
        }

        function updateSearchStatus() {
            const statusEl = document.getElementById('searchStatus');
            const total = Object.keys(bosses).length;
            statusEl.textContent = `å…± ${total} å€‹ç‹`;
        }

        function parseTimeToTodayMillis(timeStr) {
            if (!timeStr) return null;
            const [h, m] = timeStr.split(':').map(x => parseInt(x, 10));
            if (isNaN(h) || isNaN(m)) return null;
            const now = new Date();
            const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), h, m, 0, 0);
            return d.getTime();
        }

        function updateDeathTime(id, hourPart, minutePart) {
            const current = bosses[id]?.deathTime || '';
            let [h, m] = current.split(':');
            if (hourPart !== null && hourPart !== undefined && hourPart !== '') {
                h = String(parseInt(hourPart, 10)).padStart(2,'0');
            }
            if (minutePart !== null && minutePart !== undefined && minutePart !== '') {
                m = String(parseInt(minutePart, 10)).padStart(2,'0');
            }
            if (!h || isNaN(h)) h = '00';
            if (!m || isNaN(m)) m = '00';
            const value = `${h}:${m}`;
            bossesRef.doc(id).update({
                deathTime: value,
                lastUpdated: Date.now()
            }).catch(e => console.error('æ›´æ–°æ­»äº¡æ™‚é–“å¤±æ•—', e));
        }

        function createBossCard(id, boss) {
            const div = document.createElement('div');
            div.className = 'boss-card';

            const deathTime = boss.deathTime || '';
            const [dh, dm] = deathTime.split(':');
            const respawnMinutes = boss.respawnMinutes ?? boss.respawn ?? 60;
            const killTime = boss.killTime || boss.killtime || 0;
            const alertEnabled = boss.notify ?? boss.alertEnabled ?? true;

            div.innerHTML = `
                <div class="boss-main">
                    <div class="boss-name">${boss.name || 'æœªçŸ¥ç‹'}</div>

                    <div class="input-group">
                        <label>ğŸ’€ æ­»äº¡æ™‚é–“</label>
                        <div style="display:flex;gap:8px;">
                            <input type="number" min="0" max="23" placeholder="æ™‚"
                                   value="${dh || ''}"
                                   onchange="updateDeathTime('${id}', this.value, null)">
                            <input type="number" min="0" max="59" placeholder="åˆ†"
                                   value="${dm || ''}"
                                   onblur="updateDeathTime('${id}', null, this.value)">
                        </div>
                    </div>

                    <div class="input-group">
                        <label>â° é‡ç”Ÿé–“éš”(åˆ†é˜)</label>
                        <input type="number" min="1" value="${respawnMinutes}"
                            onchange="updateBoss('${id}','respawnMinutes',parseInt(this.value))">
                    </div>

                    <div class="input-group">
                        <label>âš”ï¸ æ“Šæ®ºç”¨æ™‚(åˆ†é˜)</label>
                        <input type="number" min="0" value="${killTime}"
                            onchange="updateBoss('${id}','killTime',parseInt(this.value))">
                    </div>

                    <div class="predict-times">
                        <strong>ğŸ“… æœªä¾†4æ¬¡é‡ç”Ÿæ™‚é–“:</strong><br>
                        ${predictNextSpawns({deathTime, respawnMinutes, killTime}).map((t,i)=>
                            `<div class="predict-item">ç¬¬${i+1}æ¬¡: ${
                                new Date(t).toLocaleTimeString('zh-TW',{
                                    timeZone:'Asia/Taipei',
                                    hour:'2-digit',
                                    minute:'2-digit',
                                    hour12:false
                                })
                            }</div>`
                        ).join('')}
                    </div>
                </div>

                <div class="boss-right">
                    <div class="toggle-container">
                        <span class="toggle-label">æé†’</span>
                        <div class="toggle ${alertEnabled ? 'active':''}" onclick="toggleAlert('${id}')"></div>
                    </div>
                    <div class="controls">
                        <button class="btn btn-primary" onclick="killBoss('${id}')">âš”ï¸ æ“Šæ®º</button>
                        <button class="btn btn-danger" onclick="deleteBoss('${id}')">ğŸ—‘ï¸ åˆªé™¤</button>
                    </div>
                </div>
            `;
            return div;
        }

        function predictNextSpawns(boss) {
            const times = [];
            const killTime = boss.killTime || 0;
            const base = parseTimeToTodayMillis(boss.deathTime) ?? Date.now();
            const respawnMs = (boss.respawnMinutes ?? boss.respawn ?? 60) * 60000;
            const killMs = killTime * 60000;

            let next = base + respawnMs;
            for (let i = 0; i < 4; i++) {
                times.push(next);
                next += respawnMs + killMs;
            }
            return times;
        }

        function updateBoss(id, field, value) {
            bossesRef.doc(id).update({
                [field]: value,
                lastUpdated: Date.now()
            }).catch(e => console.error('æ›´æ–°å¤±æ•—', e));
        }

        function killBoss(id) {
            const boss = bosses[id];
            const respawnMinutes = boss.respawnMinutes ?? boss.respawn ?? 60;
            const killTime = boss.killTime || boss.killtime || 0;
            const now = new Date();
            const hhmm = now.getHours().toString().padStart(2,'0') + ':' +
                         now.getMinutes().toString().padStart(2,'0');
            const nextSpawn = Date.now() + (respawnMinutes + killTime) * 60000;

            bossesRef.doc(id).update({
                deathTime: hhmm,
                nextSpawn: nextSpawn,
                lastkill: Date.now(),
                lastkill_source: 'manual',
                lastUpdated: Date.now()
            }).then(() => {
                playAlert();
            }).catch(e => console.error('æ“Šæ®ºæ›´æ–°å¤±æ•—', e));
        }

        function toggleAlert(id) {
            const current = bosses[id];
            const enabled = !(current.notify ?? current.alertEnabled ?? true);
            bossesRef.doc(id).update({
                notify: enabled,
                alertEnabled: enabled
            }).catch(e => console.error('åˆ‡æ›æé†’å¤±æ•—', e));
        }

        function deleteBoss(id) {
            const name = bosses[id]?.name || 'æ­¤ç‹';
            if (confirm(`ç¢ºèªåˆªé™¤ ${name} ?`)) {
                bossesRef.doc(id).delete().catch(e => console.error('åˆªé™¤å¤±æ•—', e));
            }
        }

        function updateGlobalCountdown() {
            const countdownEl = document.getElementById('countdown');

            let soonestTime = Infinity;
            let soonestName = '';

            Object.values(bosses).forEach(boss => {
                const respawnMinutes = boss.respawnMinutes ?? boss.respawn ?? 60;
                const killTime = boss.killTime || boss.killtime || 0;
                let next = boss.nextSpawn;
                if (!next && boss.deathTime) {
                    const base = parseTimeToTodayMillis(boss.deathTime);
                    if (base) {
                        next = base + (respawnMinutes + killTime) * 60000;
                    }
                }
                if (next && next < soonestTime) {
                    soonestTime = next;
                    soonestName = boss.name || '';
                }
            });

            if (soonestTime !== Infinity && soonestTime > Date.now()) {
                const diff = soonestTime - Date.now();
                const h = Math.floor(diff / 3600000);
                const m = Math.floor((diff % 3600000) / 60000);
                const s = Math.floor((diff % 60000) / 1000);
                const timeText = `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
                countdownEl.textContent = soonestName
                    ? `${soonestName}  ${timeText}`
                    : timeText;
            } else {
                countdownEl.textContent = 'æ‰€æœ‰ç‹å·²é‡ç”Ÿ';
            }
        }

        function setupVolume() {
            const slider = document.getElementById('volume');
            const label = document.getElementById('volumeValue');
            slider.addEventListener('input', e => {
                const v = parseFloat(e.target.value);
                alertAudio.volume = v;
                label.textContent = Math.round(v * 100) + '%';
            });
        }

        function playAlert() {
            alertAudio.currentTime = 0;
            alertAudio.play().catch(()=>{});
        }

        function openAddModal() { document.getElementById('addModal').style.display = 'block'; }
        function closeAddModal() { document.getElementById('addModal').style.display = 'none'; }

        // æ–°å¢ç‹ï¼šè®€ templates å¸¶é è¨­ï¼Œå†å¯«å…¥æœ¬æ©Ÿ bossesï¼ˆå« ownerIdï¼‰
        async function addNewBoss() {
            const name = document.getElementById('newBossName').value.trim();
            let respawnMinutes = parseInt(document.getElementById('newRespawnMinutes').value || '60', 10);
            let killTime = parseInt(document.getElementById('newKillTime').value || '0', 10);

            if (!name) {
                alert('è«‹è¼¸å…¥ç‹åç¨±');
                return;
            }

            try {
                // å…ˆçœ‹æ¨¡æ¿æœ‰æ²’æœ‰é€™éš»ç‹
                const snap = await templatesRef.where('name','==',name).limit(1).get();
                if (!snap.empty) {
                    const t = snap.docs[0].data();
                    if (t.respawnMinutes != null) respawnMinutes = t.respawnMinutes;
                    if (t.killTime != null) killTime = t.killTime;
                } else {
                    // æ²’æ¨¡æ¿å°±å»ºä¸€ç­†ï¼Œä¹‹å¾Œå…¶ä»–é›»è…¦å¯å…±ç”¨
                    await templatesRef.add({
                        name,
                        respawnMinutes,
                        killTime,
                        createdAt: Date.now()
                    });
                }

                await bossesRef.add({
                    ownerId: OWNER_ID,
                    name: name,
                    respawn: respawnMinutes,
                    respawnMinutes: respawnMinutes,
                    killTime: killTime,
                    notify: true,
                    alertEnabled: true,
                    lastUpdated: Date.now()
                });

                document.getElementById('newBossName').value = '';
                document.getElementById('newRespawnMinutes').value = '60';
                document.getElementById('newKillTime').value = '0';
                closeAddModal();
            } catch (e) {
                console.error('æ–°å¢å¤±æ•—', e);
                alert('æ–°å¢å¤±æ•—ï¼š' + e.message);
            }
        }

        window.onclick = function(e) {
            const modal = document.getElementById('addModal');
            if (e.target === modal) closeAddModal();
        };

        window.addEventListener('load', init);
    </script>
</body>
</html>
